#include "RainbowLexerFront.h"
RainbowLexerPrivate(int) RainbowFrontStatusCheekOfStaticWordValidity(const char *token)
{
    switch (*token++)
    {
    case 'I':
    {
        switch (*token++)
        {
        case 'G':
        {
            switch (*token++)
            {
            case 'N':
            {
                switch (*token++)
                {
                case 'O':
                {
                    switch (*token++)
                    {
                    case 'R':
                    {
                        return 3;
                        break;
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        default:
        {
            return -1;
            break;
        }
        }
    }
    case 'N':
    {
        switch (*token++)
        {
        case 'U':
        {
            switch (*token++)
            {
            case 'M':
            {
                switch (*token++)
                {
                case 'B':
                {
                    switch (*token++)
                    {
                    case 'E':
                    {
                        return 14;
                        break;
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        default:
        {
            return -1;
            break;
        }
        }
    }
    case 'S':
    {
        switch (*token++)
        {
        case 'T':
        {
            switch (*token++)
            {
            case 'R':
            {
                switch (*token++)
                {
                case 'I':
                {
                    switch (*token++)
                    {
                    case 'N':
                    {
                        switch (*token++)
                        {
                        case 'G':
                        {
                            switch (*token++)
                            {
                            case '_':
                            {
                                switch (*token++)
                                {
                                case 'S':
                                {
                                    switch (*token++)
                                    {
                                    case 'I':
                                    {
                                        switch (*token++)
                                        {
                                        case 'N':
                                        {
                                            switch (*token++)
                                            {
                                            case 'G':
                                            {
                                                switch (*token++)
                                                {
                                                case 'L':
                                                {
                                                    return 12;
                                                    break;
                                                }
                                                default:
                                                {
                                                    return -1;
                                                    break;
                                                }
                                                }
                                            }
                                            default:
                                            {
                                                return -1;
                                                break;
                                            }
                                            }
                                        }
                                        default:
                                        {
                                            return -1;
                                            break;
                                        }
                                        }
                                    }
                                    default:
                                    {
                                        return -1;
                                        break;
                                    }
                                    }
                                }
                                case 'D':
                                {
                                    switch (*token++)
                                    {
                                    case 'O':
                                    {
                                        switch (*token++)
                                        {
                                        case 'U':
                                        {
                                            switch (*token++)
                                            {
                                            case 'B':
                                            {
                                                switch (*token++)
                                                {
                                                case 'L':
                                                {
                                                    return 13;
                                                    break;
                                                }
                                                default:
                                                {
                                                    return -1;
                                                    break;
                                                }
                                                }
                                            }
                                            default:
                                            {
                                                return -1;
                                                break;
                                            }
                                            }
                                        }
                                        default:
                                        {
                                            return -1;
                                            break;
                                        }
                                        }
                                    }
                                    default:
                                    {
                                        return -1;
                                        break;
                                    }
                                    }
                                }
                                default:
                                {
                                    return -1;
                                    break;
                                }
                                }
                            }
                            default:
                            {
                                return -1;
                                break;
                            }
                            }
                        }
                        default:
                        {
                            return -1;
                            break;
                        }
                        }
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        default:
        {
            return -1;
            break;
        }
        }
    }
    case '_':
    {
        switch (*token++)
        {
        case '_':
        {
            switch (*token++)
            {
            case 'V':
            {
                switch (*token++)
                {
                case 'A':
                {
                    switch (*token++)
                    {
                    case 'R':
                    {
                        switch (*token++)
                        {
                        case '_':
                        {
                            return 11;
                            break;
                        }
                        default:
                        {
                            return -1;
                            break;
                        }
                        }
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        default:
        {
            return -1;
            break;
        }
        }
    }
    case 's':
    {
        switch (*token++)
        {
        case 't':
        {
            switch (*token++)
            {
            case 'a':
            {
                switch (*token++)
                {
                case 't':
                {
                    switch (*token++)
                    {
                    case 'i':
                    {
                        switch (*token++)
                        {
                        case 'c':
                        {
                            switch (*token++)
                            {
                            case 'W':
                            {
                                switch (*token++)
                                {
                                case 'o':
                                {
                                    switch (*token++)
                                    {
                                    case 'r':
                                    {
                                        return 1;
                                        break;
                                    }
                                    default:
                                    {
                                        return -1;
                                        break;
                                    }
                                    }
                                }
                                default:
                                {
                                    return -1;
                                    break;
                                }
                                }
                            }
                            default:
                            {
                                return -1;
                                break;
                            }
                            }
                        }
                        default:
                        {
                            return -1;
                            break;
                        }
                        }
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        case 'w':
        {
        }
        case 'p':
        {
            switch (*token++)
            {
            case 'e':
            {
                switch (*token++)
                {
                case 'r':
                {
                    switch (*token++)
                    {
                    case 'a':
                    {
                        switch (*token++)
                        {
                        case 't':
                        {
                            switch (*token++)
                            {
                            case 'o':
                            {
                                return 2;
                                break;
                            }
                            default:
                            {
                                return -1;
                                break;
                            }
                            }
                        }
                        default:
                        {
                            return -1;
                            break;
                        }
                        }
                    }
                    default:
                    {
                        return -1;
                        break;
                    }
                    }
                }
                default:
                {
                    return -1;
                    break;
                }
                }
            }
            default:
            {
                return -1;
                break;
            }
            }
        }
        default:
        {
            return -1;
            break;
        }
        }
    }
    default:
        return -1;
        break;
    }
}
RainbowLexerPrivate(int) RainbowFrontStatusCheekOfStaticWordValiditySp(const char *token)
{
    switch (*token++)
    {
    case '	':
    {
        return 25528;
        break;
    }
    case '\n':
    {
        return 25527;
        break;
    }
    case ' ':
    {
        return 25526;
        break;
    }
    case ',':
    {
        return 16;
        break;
    }
    case '-':
    {
        return 15;
        break;
    }
    case ':':
    {
        return 17;
        break;
    }
    case '[':
    {
        return 13;
        break;
    }
    case ']':
    {
        return 14;
        break;
    }
    case '{':
    {
        return 11;
        break;
    }
    case '}':
    {
        return 12;
        break;
    }
    default:
        return -1;
        break;
    }
}
RainbowLexerPublic(int) RainbowFrontStatuSperatorMatch(const char *token)
{
    int id = RainbowFrontStatusCheekOfStaticWordValiditySp(token);
    switch (id)
    {
    case 25528:
    {
        return 0;
        break;
    }
    case 25527:
    {
        return 0;
        break;
    }
    case 25526:
    {
        return 0;
        break;
    }
    case 16:
    {
        return 0;
        break;
    }
    case 15:
    {
        return 0;
        break;
    }
    case 17:
    {
        return 0;
        break;
    }
    case 13:
    {
        return 0;
        break;
    }
    case 14:
    {
        return 0;
        break;
    }
    case 11:
    {
        return 0;
        break;
    }
    case 12:
    {
        return 0;
        break;
    }
    default:
    {
        return -1;
        break;
    }
    }
}
RainbowLexerPrivate(int) RainbowCheekID_DELET(int id,int *id_list)
{
    while (*id_list!=-1)
    {
        if(id == *id_list)return 1;
        id_list++;
    }
    return 0;
}
RainbowLexerPublic(void) RainbowFrontLex(const char* string,int* id_list)
{
    /* 将string解析
        并加入到ret列表中
    */
    const char* strptr = string;
    WHITESPACE_SKIP(strptr);
    char buf[BUF_SIZE] = {'\0'};
    size_t index = 0;
    while(*strptr != '\0')
    {
            if(*strptr == '\"'&& !(RainbowCheekID_DELET(RainBowLexer_id_string,id_list)))//处理字符串
            {
                if(*buf!='\0')
                {
                    int id = 0;
                    id = RainbowStatusCheekOfStaticWordValidity(buf);
                    if(RainbowCheekID_DELET(id,id_list))id = -1;
                    if(id >= 0) RainbowRetAdd(buf,id);
                    else if(isalpha(*buf)&&(RainbowStatusCheekVarNameValidity(buf) != -1)&&RainBowLexer_id_var!=-1)
                        if(RainbowCheekID_DELET(RainBowLexer_id_var,id_list))goto ERROR;
                        else RainbowRetAdd(buf,RainBowLexer_id_var);
                    else if(isdigit(*buf)&&(RainbowStatusCheekNumValidity(buf) != -1)&&RainBowLexer_id_num!=-1)RainbowRetAdd(buf,RainBowLexer_id_num);
                        if(RainbowCheekID_DELET(RainBowLexer_id_num,id_list))goto ERROR;
                        else RainbowRetAdd(buf,RainBowLexer_id_num);
                    else//错误处理
                    {
                        ERROR:
                        RAINBOW_RAISE(UndefineToken);
                        printf("%s\n",buf);
                        getchar();
                        putchar('\n');
                    }
                }
                char* string = RainbowStatusCheekOfString(strptr+1,'\"');
                if(string == NULL)return;
                int len = strlen(string);
                strptr+=len+2;
                RainbowRetAdd(string,RainBowLexer_id_string);
                continue;
            }
            int spRet = RainbowStatuSperatorMatch(strptr);
            if(*buf == '\0' && spRet >= 0) goto BUF_EMPTY_CASE_;//处理第一个字符是分隔符的情况
            if(spRet >= 0)
            {   
                int id = 0;
                id = RainbowStatusCheekOfStaticWordValidity(buf);
                if(RainbowCheekID_DELET(id,id_list))id = -1;
                if(id >= 0) RainbowRetAdd(buf,id);
                else if(*buf != '\0' && isalpha(*buf)&&(RainbowStatusCheekVarNameValidity(buf) != -1)&&RainBowLexer_id_var!=-1)
                    if(RainbowCheekID_DELET(RainBowLexer_id_var,id_list))goto ERROR;
                    else RainbowRetAdd(buf,RainBowLexer_id_var);
                else if(*buf != '\0' && isdigit(*buf)&&(RainbowStatusCheekNumValidity(buf) != -1)&&RainBowLexer_id_num!=-1)RainbowRetAdd(buf,RainBowLexer_id_num);
                    if(RainbowCheekID_DELET(RainBowLexer_id_num,id_list))goto ERROR;
                    else RainbowRetAdd(buf,RainBowLexer_id_num);
                else if(*buf == '\0')goto BUF_EMPTY_CASE_;//用于处理多个连续分隔符的情况
                else//错误处理
                {
                    ERROR:
                    RAINBOW_RAISE(UndefineToken);
                    printf("%s\n",buf);
                    getchar();
                    putchar('\n');
                }

                BUF_EMPTY_CASE_:
                memset(buf,'\0',BUF_SIZE);
                index = 0;
                for (size_t i = 0; i <= spRet; i++)buf[i] = *strptr++;
                RainbowRetAdd(buf,RainbowStatusCheekOfStaticWordValiditySp(buf));
                memset(buf,'\0',BUF_SIZE);
            }
            else
                buf[index++] = *strptr++;
    }
    
    if(*buf == '\0')return;//buf已空  情况出现在最后一个字符是分隔符时

    //清理buf
    if(id >= 0) RainbowRetAdd(buf,id);
    else if(*buf != '\0' && isalpha(*buf)&&(RainbowStatusCheekVarNameValidity(buf) != -1)&&RainBowLexer_id_var!=-1)
        if(RainbowCheekID_DELET(RainBowLexer_id_var,id_list))goto ERROR;
        else RainbowRetAdd(buf,RainBowLexer_id_var);
    else if(*buf != '\0' && isdigit(*buf)&&(RainbowStatusCheekNumValidity(buf) != -1)&&RainBowLexer_id_num!=-1)RainbowRetAdd(buf,RainBowLexer_id_num);
        if(RainbowCheekID_DELET(RainBowLexer_id_num,id_list))goto ERROR;
        else RainbowRetAdd(buf,RainBowLexer_id_num);
    else//错误处理
    {
        ERROR:
        RAINBOW_RAISE(UndefineToken);
        printf("%s\n",buf);
        getchar();
        putchar('\n');
    }
    return;
}

